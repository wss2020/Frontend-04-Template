<!--
Object 和 Symbol
相比于Object 来说 Symbol 其实是一个配角，

Object
三个一摸一样的鱼，其实是三个对象，
其实一条鱼发生了状态改变，失去了尾巴。
其它两条鱼并不受到影响。
因为，当我们在计算机中描述这三条鱼时，必须把相同的数据存储三份。
因为这是三个对象的状态，而不是我们把同一个数据存了三份，只是它们恰巧相等罢了，其实这个正是
所有的面向对象编程的一个基础。

说对象，它是这条鱼，就是这条鱼，不是这条鱼，就不是这条鱼，它不会因为对象本身的状态改变而变
得有区别。

所以，任何一个对象都是唯一的，这与它本身的状态无关。
所以我们在设计语言里面对象相等这个问题，即使状态完全一致的两个对象，也并不相等。
我们用状态来描述对象。
我的状态的改变即使行为。

有的时候，我们会把对象当数据用，但是这个其实是一种语言使用的技巧， 并不是一个坏事，
但是它也并不是把对象在当做对象用，另一些典型的场景，比如说我们传一个 config ，其实
传 config 的过程，其实它并不是把对象当对象去传，而是我们把对象当成一种数据载体去传，
这个时候其实我们就涉及到我们对对象类型的使用，跟语言原本的涉及用途的一些偏差，我想大家
应该去关注这个点。

我们会用状态来描述对象，很好理解，对象上面它这个鱼有没有尾巴，眼睛有多大是吧，我们有
可能会去用一些值来描述一个对象，这些值就是它所谓的状态，而这个状态其实是一个客观事实
存在的一个状态，我们只是用一个数据去描述它，这些状态改变的就是行为，状态的改变，就是
这鱼尾巴没了，我们认为这个状态的改变就是行为，它们隶属于行为。
-->

<!--
我们在认知里面一条鱼一个对象，那么它其实是由三个核心的要素组成的，那么分别是一个唯一性
的标识，还有一个是一个状态，还有一个就是行为；
咱们说变量才有一个唯一标识性，只要在你的认知里，他是一个具有明确的标识性的东西，我们就
说这个是对象的一个核心要素具备了，
他又有状态，那么它可以被改变，那么这就是一个对象的三要素成立了。

通常就是咱们脑子里的任何一个概念，和现实生活中的一个物品，它都可以成为一个对象。
-->
<!--
我们认识对象的一个重要的方式叫做分类，我们描述对象的时候就是可以用分类的方法去描述，
比如说这个鱼，我研究明白了一条鱼之后，可能跟它所有同类型的鱼，我就因为他们大部分的
特征差不多，那么所以说我们把它分成鱼，那么其实在鱼的上面可能还有 Animal（动物分类），
动物的下面有可能有别的分类这个 Sheep, 所以说鱼跟羊之间他们的关系，他们的共性，我们
就会用动物来描述都会生崽，鱼是卵生的，羊是胎生的，但是他们都会繁衍，然后我们一层一层的
抽象，可能到 Animal 之上还会有这个 Object，类就是一个非常常见的描述对象的一种方式，
你看咱们的生物就会把所有的生物分成，界门纲目科属种，一个一个往下分。   咱们通常写代码
的时候，分类是一个为业务服务的，咱们没必要分那么细，就有共性需要写的代码里，我们就提一
下把 Animal 提出来，就差不多了，我们就不再说分什么这个哺乳动物还是什么卵生。

分类有两个流派，一种叫做归类，一种叫做分类；
归类很多理解，我们去研究单个的对象，然后我们从里面提取共性，然后把它们变成类，变成类之后，
我们又在类之间去提取共性，把它们变成更高的抽象类，比如我们在鱼和羊之间提取共性，然后得到了
Animal 类；
然后分类则是我们把世间万物，首先都抽象为一个基类 Object ,然后我们首先分说 Object 里面
有什么，一般来说，我们不会 Object 下面就是 Animal，可能中间还隔了几层。
但是就归类的方法而言，多集成就是一个非常自然的事，因为我可以做多个抽象，所以说我这个鱼可以
归为 Animal，可以归为动物，它可以归属于多个类；
但分类不一样，一般来说，我们一级一级的分，你要不属于这个类，要不属于那个类，它只有一个从属
关系；
所以对于归类而言，多继承是非常自然的一个事情，比如说咱们 C++ 里面就是各种多继承，菱形继承，
什么三角形继承非常复杂的一个结构关系，而采用分类思想的计算机语言都是单继承的结构，就都会有
一个基类 Object 的，典型的比如说 C# Java 都属于基于分类思想，那么咱们的JavaScript的
Class ，它其实比较接近分类的思想，但是它也不完全是分类的思想，因为我们 JavaSCript 其实
是一个多范式的面向对象的语言。
-->

<!--
JavaScript 采用的描述对象的方式
Object---Prototype
原型是一种更接近人类原始认知的描述对象的方法。
我们并不试图做严谨的分裂，而是采用"相似"这样的方式去描述对象。
任何对象仅仅需要描述它自己与原型的区别即可。

其实分类 Class Based 的 Object，并不是一个唯一的认识对象的方法；
原型，咱们有句话叫照猫画虎，就是用的一种原型的方法，
比如我们要研究鱼，我们找一只具体的鲤鱼，我们把它所有的特征全都加到鱼类的原型上，
然后其他的鱼只要有对象，那么我们就根据它，去进行修改，比如说鲶鱼比鲤鱼能吃，我
们就在鲤鱼的基础上把特征加上去，他就是描述鲶鱼了。
然后比如说，我们有个羊，羊，也有一只典型的羊，小绵羊，山羊怎么样，多胡子是吧，这
脚又是弯的，又长又硬也能爬山，我们就在绵羊的基础上去改就可以了；
动物可能我们也选一只原型，虎四个蹄，但是动物不一定四个蹄，但是原型选择相对来说它
比较自由，比如说你选蛇作为动物的原型，你就是描述鱼的时候费点劲，描述猫的时候更费
劲，然后原型它可能有一个最终版的原型，脚 Object Prototype ，这个是所有的物品
的一个典型的物品，那么这个东西上就是可以是咱们所有的，对象的一个老祖宗，我们都是
从它跟它的区别来进行描述的，而在它的上面一般来说是不再有原型，我们有时候会允许有
一些语言里面，我们就会允许这种 Nihilo 的原型，Nihilo 是什么就是说虚无空虚，这
个是一个语言中立的讲法，如果我们用JavaScript 的具体的设施来描述，它就是 Null
原型是 Null，大家就熟了，我们很轻易的就可以造出来原型是 Null 的对象。

原型认知的成本低，选错的成本也比较低，那么所以说原型更适合一些不那么清晰，我们描
述的比较自由的这样的一些场景， 而这个分类 Class 更使用一些比较严谨的场景，另外
Class 它有一个优势，就是它天然的跟类型系统是有一定的整合的，所以说很多语言就会
选择把Class 的继承关系，整合进类型系统的继承关系，大家要知道 Class 跟 Type
其实是两个概念。
-->
<script>
// 狗咬人

//错误例子
class Dog{
    bite(human){
        //....
    }
}
// 上面是一个错误的抽象，违背了面向对象的基本的特征，我们不说 class base 或者
// 是prototype base，不管你设计成那个，只要这个bite 发生在狗身上，那么它就是
// 错的啊，为什么错？ 我们前面已经讲了面向对象的三要素，这个行为对象的行为，不是
// 说我们现实中的对象的行为，而是改变对象状态的行为，这个 bite 这个动作改变了
//谁的状态，如果是狗吃人可能 bite 勉强还是可以安到狗身上的是吧，eat 吃了以后
// 狗饱了，但是咬人我们可以基本认为他对狗的状态，是没有改变的，然后人发生了改变，
//但是我们要在人身上是要设计出一个 biteBy 吗？被狗咬的这样的一个方法吗？似乎也
// 不太对，为什么呢？ 因为人身上是改变人状态的行为，改变人状态的行为，它的命名应
// 该是怎么样的呢？

class Human{
    hurt(damage){
        //....
    }
}
// 我们不因该受到语言描述的干扰。
// 在设计对象的状态和行为时，我们总是遵循"行为改变状态"的原则。

// 对人来说，只需要关心我收到了什么样的伤害，不需要关心是被狗咬还是谁咬的。
// 那么狗咬人这个是一个业务逻辑，当我们设计 人 这个 class 的时候，我们只
// 设计改变 Human 对象内部的状态的这样的一个方法，所以它正确的命名应该是
// hurt , 至于这个 damage 是什么格式，它有可能可以是从狗的 bite 这个
// 行为里面，生成出来的，但是它绝对不可能是直接传一只狗，这样的对象进来的，
// 这肯定不符合我们对对象的抽象。

</script>




<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
