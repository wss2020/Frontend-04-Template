<!--
声明
    FunctionDeclaration
    GeneratorDeclaration
    AsyncFunctionDeclaration
    AsyncGeneratorDeclaration
    VariableStatement
    ClassDeclaration
    LexicalDeclaration

声明在大家的印象中，可能会有这个函数声明、类的声明 和 变量声明这么几种。
在 JavaScript 的语法树里声明的定义，不是特别的统一，一般来说我们认为是声明的变量声明，它基于
就是用 var 关键字进行的变量声明，它也会被归类到语句里面去，然后我们去看这个语法，你会发现它有
一堆的函数声明，const 和 let ,被归为 LexicalDeclaration ，那么在我理解，其实凡是这些有
对后续的语句发生作用的这种语句，我都把它归类成了声明，所以说我们这里分出来的声明是一个在我的
概念中的这样的一个声明，跟 JS 的标准的划分并不完全一致。
然后 Function 是一个非常特殊的这样的一种声明，Function 声明它有 4 种形态：
Function关键字后面加 * 他就是一个 Generator 声明，
Function 前面加 Async 关键字就是一个 异步的函数声明，
两个都加就是异步的产生器，这样的一个声明，
所以函数声明就占了4种。

然后就是 VariableStatement 变量声明， VariableStatement 它既有声明的作用，又有实际的
执行计算的能力，所以说有的时候大家也比较纠结，这个东西到底算声明还是算语句呢？显然在 JS 标准
里面，它的语法上把它划归了语句。

再有就是新加的三种声明 ClassDeclaration  const  和 let, const 和 let 又被统称为
LexicalDeclaration ，这个里面新加的一种声明，它的行为相对来说是比较统一的，老的用
Function 和 var 声明，它的行为又是比较统一的，接下来就来看一看声明是怎么回事。
-->

<!--
声明
    function               class
    function *             const
    async function         let
    async function*
    var

我们看左边的这一排声明，左边的这一排5个声明它都有一个共同的特点，特点是什么，就是它的作用范围
只认 Function Body, 你其他的东西都不好使，而且它是没有先后关系的，他们是永远会被当做出现
在函数的第一行一样去处理，所以我们的 Function 你写在这个函数尾，也是没有关系的，那么你在一个
函数体里面，你在声明一个局部的Function, 写在最尾巴上面，但是你在前面一样可以访问到这个
Function。
var 它比较特殊，var 的声明作用是相当于出现在函数的头部，但是它实际上后边的表达式，如果我
们写 var a = 1;这个变量已经被声明为了一个函数级的局部变量，但是它后边的一个赋值并没有发生，
这是它跟 Function 声明的一个区别， 具体的4种函数，四种函数，这里不给大家细讲，结构化的部分，
再给大家细说。

接着说一说，右边的 class const 和 let ,这三个声明也有一个共性，当你在他们的声明之前去使用的
时候，它就会报错， 这个并不是说他们的声明就没有作用，比如说你在外面声明了一个 class a ，你在
函数的里面又声明了一个 class a ,这个时候你在里边 class a 的声明之前，访问这个 a ,它就会给
你抛错，然后 const 和 let 也一样，它实际上也是有一个预处理的能力的，只是说它确保了你只要在它
声明之前使用，就会报错，右边是新加的特性。


大家可以看到左边的 function 和 var 的行为，其实可以理解为一种历史包袱，右边才是现代的 JS
的语言编委会希望它编程的一种样子，所以我们在编程中鼓励大家尽量使用右边的 class const 和 let
这种风格的声明。
-->

<!--
预处理（pre-process）
var a = 2;
void function(){
    a = 1;
    return ;
    var a;
}();
console.log(a);


var a = 2;
void function(){
   a = 1;
   return;
   const a;
}();
console.log(a);

所谓预处理是指在一段代码执行之前，JavaScript 引擎它会对代码本身做一次预先处理，这样的一种机制，
在我们的例子中，
左边的例子，void  function(){} 里面的第一行有 a=1, 第二行是个 return ,最后一行是 var a;
理论上讲 var a 在 return 之后，所以它并不会被执行到，但是我们的预处理是不管这些的，预处理它会
提前去找到所有的 var 声明的变量，并且让它去生效，所以大家会看到这个 a=1 确确实实的被声明在了这个
function 的作用域之内， 你会发现打印出来的结果是 2，也就是说 a = 1;并没有改到外边的这个
var a = 2 的这个 a ,它被里面的 var a 给占据了，这就是所谓的预处理机制造成的咱们的代码的一个
执行的效果，大家需要特别的注意，var 不管写在函数里面的哪一个位置，不管是写在if 里面，还是写在
return 之后，甚至写在 catch 里面 finally 里面，都没有任何区别，它都会被预处理挑出来，把这个
变量声明到这个函数的作用级别。

接下来我们来看看 const 有什么区别，有一种说法是说这个 const 它并没有预处理机制，这个说法其实
也是错的，当我们把左边的 var a 换成 const a 的时候，你会发现这个变量 a 成为了一个局部的变量，
它还是会执行抛错，并且它其实并没有影响到外边的变量a,  也就是说如果我们给这个函数的外面套一个
try-catch 的话，最后你会发现打印出来的结果它仍然是 console.log(a) 得到的是 2。

强调几点，
第一，所有的声明都是有预处理机制的，它都能够把变量变成一个局部变量；
第二，区别是 const 声明，它在你声明之前使用的话，它会抛错，而且这个错误是可以被 try 和 catch
     去处理的。
-->

<!--
作用域
var a = 2;
void function(){
    a = 1;
    {
       var a;
    }
}();
console.log(a);



var a = 2;
void function(){
    a = 1;
    {
       const a;
    }
}();
console.log(a);

这里讲讲作用域的概念，在 JS 里面作用域是一个常考的题，大家应该也听过一个叫做所谓的作用域链，这样的
一个概念，但是在今天作用域链这个概念，我认为大家应该把它忘记了，因为作用域链这个概念来自更早的标准，
ECMA Script3.0 的时代，现在按照标准的版本号已经是 10.0 了，我们一般都不叫它 ES10 ,我们会叫
它 ECMA Script2019 或者是 2018 ，我们是后面就开始用年限来编号了，早期的 JavaScript 设计中，
var 和 function ，这样的声明， 它的作用范围都是整个的函数体，不管你把 var 写在哪，外面套上什么
东西，它最终的它的作用范围都是这个函数体，为什么咱们要讲这个标题叫做作用域，因为咱们今天没有讲它的
运行时机制，咱们讲的是在代码里面变量从哪到哪发生作用，这个东西就叫作用域，那么我们可以看到 var 的
作用域是它前后都有的，它的作用域是它所在的函数体，正是因为咱们前面讲的预处理机制，所以它才有这种能
力，
而 const 就不一样了，const 的作用域就在它所在的花括号。
如果我们是在循环语句，我们有一些循环语句是可以在里面加 const 声明的，如果我们在这里用了 const
或者 let 声明，那么它的作用域就是整个的循环语句，它比循环语句里面的花括号范围要大，因为它每次循
环都不产生新的，大家要注意这一点，const 这样的声明作用的范围，就是自己外层的 block 语句，咱们
前面已经讲过了 block 语句了。

如果大家想要局部的去声明一些变量，或者说有些同学觉得在函数里面，我们去使用 const 有点烦，因为有
的时候你用重或者声明重了，它就会报错，那么大家可以尝试，我们用花括号把函数分成小节，最近咱们也有
一些框架出来， React 的 Hooks ，也有 vue3.0 的 conversation API ，咱们以后写大函数，
将会变成一个经常会发生的事情，大家配合 const let 和 class 的这种声明的作用域，我们就可以使用
这样的基础设施了。  用花括号一分隔，整个函数的结构非常的明确，也不会产生前后的变量干扰。




总结：
   简单语句
   组合语句
   声明

   简单语句 其中最重要的就是表达式语句，它是由一个表达式后面跟一个分号来组成的，因为有等号的
存在，所以简单语句其实是有一定的副作用，也就是说它可以改变一些状态的；
   组合语句多用于控制简单语句的执行顺序，常见的有这个条件，有这个循环，每一种语句，它都有一个结构
的关系，这里面我们需要特别注意的是，try catch 和  finally , 它的里面并不是用这个 block 语句，
来制造的这种多语句执行的环境，所以 try 后面的花括号是不能够省略的；
   此外，通过 Completion Record 这样的一个抓手，我们了解了整个语句，组合语句是如何实现控制能
力的，Completion Record 决定了我们的语句是继续向下执行，还是停止执行，然后我们不同的组合语句
会用不用的方式，去利用 Completion Record ，最终达成我们想要的这种控制效果，不管你分支还是循环，
捕获异常，返回这些都是由 Completion Record 也就是语句的完成状态来决定的。
  最后我们讲了声明，我们了解了 JS 中 新旧两代的声明体系，在新的声明中，我们是局部作用域并且它的
预处理会帮助，我们把所有在它使用之前使用的声明的变量，都给它抛错，所以也推荐大家尽量使用我们的新一
代的声明 let  const  和 class .
  在没有必要的情况下，我们就不用老一代的声明了，Function 系列的。



-->





<script>
    var a = 2;
    void function(){
        a = 1;
        return ;
        var a;
    }();
    console.log(a);   //2
</script>


<script>
    try {
        var c = 2;
        void function () {
            c = 1;
            return;
            let c;
            // const c;
        }();
        console.log(c);   // 2
    } catch (res) {
        console.log(res);
    } finally {
        // console.log(c);
    }
</script>

<script>
    var d =123;
    function test(){
        d = 124;
    }

</script>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
