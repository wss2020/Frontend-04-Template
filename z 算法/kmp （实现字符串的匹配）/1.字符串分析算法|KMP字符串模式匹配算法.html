<!--
   模式匹配：我们查一个字符串里，有没有另一个字符串。
   它有一个原串，就是我们要待查的串，   还有一个比较短的叫做 pattern 串，
   pattern 串，用于表示说 我要在长串里面去找短的字符串。

   KMP就是用来解决这样的一个问题。

   那么如果我们先不考虑 KMP 算法，如果我们用一个最朴素的算法，比如说叫 Brute-Force（BF），著名的算法 暴力解。
   怎么搞： 我们从长的字符串的每一个节点开始，它每个位置开始，然后去匹配，看有没有能够匹配到 pattern 的串。
   这个算法的时间复杂度是 m * n，假如：原串跟模式串 它们两个的长度各为 m n 的话。

   看看KMP是如何做的；
   pattern：abcdabce

   source：abcdabcdabcex

   如果是或用，暴力的解法，我们从source 的第一个开始字符开始，依次去和 pattern 比较，然后看它匹不匹配。



  字符串自重复的特性，我们采用了一个表格的形式，
  a b c d a b c e
  0 0 0 0 0 1 2 3

  我们创建了一个，跟这个模式串长度相同的这样的一个数组，然后我们在里面，分别填上
到此的时候，已经有几个字母是重复的了，比如说，我们叫abcdabce, 第二个b 的时候，
我们发现前面的一个 a 已经匹配到了，所以我们在这个表格里面就标注 1，到 c 的时候，
我们发现前面的 b 已经匹配掉了，所以我们标注 2 ,到 e 的时候前面 abc 都已经匹配到了，
所以我们标记3。

那么当我们做原串跟模式串的对比的时候，我们如果发现，模式串里面的e,它不能够匹配的话，
那么我们不着急回到最开始的状态，我们先看一看，前面有几位是重复的，那么我们就把重复的，
我们先把模式串里面的位置，跳到重复的位置，比如说，这个地方叫做 d 对不对，那么我们看
d 匹配不匹配，如果d 匹配的话，那么我们还是会从这个 d 开始，继续往后去匹配，那么如果
这个 d 也不匹配，我们发现因为 d 前面是 0 ,所以说它就一步跳到 0 这个位置了，那就相
当于从头再来了。



a b a b a b c
0 0 0 1 2 3 4

然后我们看一个复杂的例子，abababc 这个时候到 c 的时候，已经有 4 位匹配上了，那么它会回到，
第 4 位，4 号位，那么 4 号位我们发现，如果说原串里面的字母，它不是 c 也不是 a 的话，那么我们
会再往回跳一下，看看它是不是这个位置的a, 如果不是，我们就会把它跳回到 0 的位置也就是最开始的位置，
这个就是我们 KMP 匹配的这样的一个回退的表格。

KMP 算法首先我们是要根据模式串，去算出来这个跳转表格，然后我们拿这个跳转表格，去拿原创跟模式串去做对比，
我们的KMP 算法，大致就是分成两个部分，第一个部分就是求这个跳转表格，第二个部分就是进行真正的匹配。


 a a b a a a c
 0 0 1 0 1 2 2

本来到c 的时候，c前面的 a 并不匹配 b ,但是其实c前面的两个a是匹配的，所以
到c 这里，前面的 a 匹配是 2。



-->

<script>
    function kmp(source, pattern) {
        // 计算table
        let table = new Array(pattern.length).fill(0);
        //比如说 abcdabce,那么我们首先要考虑的，就是自重复串的开始的位置，我们会用一个 let i = 1,
        //来表示，表示 i 它至少是从 1 开始了，从 0 开始整个串的都是自重复的。
        // 我们看这个里面，有没有自重复，我们就会从1开始，那么已重复的次数，我们就用 j 来表示。
        // 然后我们就写一个循环，从 i 开始去算它的自重复的数字，
        // 我们看循环体里面怎么写，首先就是 i j 这两个位置，它是相等的，这种情况就皆大欢喜，说明匹配上了有自重复。
        // 然后我们就给它，i 和 j 都自增，因为都匹配上了，所以我们就要在 table 里面记一笔了，
        // 这个时候我们认为，它的 table[i] 这个位置的重复数就是 j,然后我们来看，不匹配的情况怎么办？
        // 不匹配，其实大家可以想，最基本的逻辑就是把 j 变成 0;
        // 但是我们要注意一个事情，就是它自重复的意思就是说，它其实有可能，它是这样的一个结构，
        // 比如说 aabaaac ，这种情况下，匹配到 a 的时候，虽然说这个第5个 a ,不能够跟 b 匹配，
        // 但是它能跟第2个 a 匹配，所以说这个地方要变成 2 ,所以说，这个地方就是一个重要的技巧了。
        // 这个地方它还不能是 j = 0; 它得是 j 等于 table[j] ，
        // 这里又有一个问题，那 j 如果已经等于 0  的时候，table[j] 也是 0 对不对，
        // 所以说，我们还要加一个判断就是 if table[j] > 0;
        // 剩下的情况，我们就让它 i 还往前走一格了，++i ；那说明没匹配上吗，这就说明什么都没匹配上。
        // 这个时候，我们要给它写一笔   table[i] = j;
        {
            // a a b a a a c         a b c d a b c e
            // 0 0 1 0 1 2 2         0 0 0 0 0 1 2 3
            let i = 1 , j = 0;
            while (i < pattern.length) {
                if (pattern[i] === pattern[j]) {
                    ++j , ++i;
                    table[i] = j;
                } else {
                    // j = 0;
                    if (j > 0)
                        j = table[j];
                    else {
                        ++i;
                    }
                }
            }
        }

        // console.log(table);

// 上面表格是正确的，因为下一步还是要用到 i j ,所以说这个地方，我们有一个
//javaScript 小技巧，把上面的逻辑，放进一个代码块里  {},这样 i j 它就变成一个局部的了。
// 我们代码的局部性，体现的就非常好，这样上面，只有 table 它是一个全局的这样的东西。


// 匹配
// 匹配 i j 它一开始都是 0，我们把 j 认为是 pattern 串的位置，i 认为是 source 串的位置，
// 最后你会发现，我们最后写出来的算法，和上面的非常的相似。
// 我们先看匹配上的情况，匹配上了，那么就是 pattern[j] === source[i],这时候，同样是个自增的逻辑，都进一格，非常开心。
// 如果没有匹配上，是不是我们的 pattern 的位置就要回退到 table 去了。
// 是不是同样的有这个，到 0 的问题，
// 然后什么时候结束呢？看一下，如果我们的模式串，匹配到头了，那么就说明结束了，
// 所以我们要在这个地方加一个， if(j === pattern.length)
// 如果说是这个 source 串到头了，怎么办？   最后 return false;
        {

            let result = [];

            let i = 0, j = 0;
            while (i < source.length) {
                if (pattern[j] === source[i]) {
                    result.push(i);
                    ++i, ++j;
                } else {
                    if (j > 0)
                        j = table[j];
                    else
                        ++i;
                }

                // 这里说明找到了，此时 j 才等于 pattern.length
                if(j === pattern.length)
                    // return true;
                   // 这样写，代表在原字符串中，匹配的开始位置。
                    return result.pop() - pattern.length + 2;
            }
            return false;

        }

    }


    // a a b a a a c
    // 0 0 1 0 1 2 2

    // 传一个字符串来看看，
    let result =  kmp("dddawwwacddd","acddd");

    console.log(result);


    // 总结： KMP 算法， 计算table 的逻辑 和 模式匹配的逻辑，他俩的结构，基本上是一致的;
    // 就差了一个 source ,然后模式匹配 最后加了一个结束的判断；
    // 当然这个里面，也可以直接去计算出来，它匹配在那个位置。


    // 推荐解决一下， LeetCode 的 28 这个问题，这个是一个非常标准的一个 KMP 问题。


</script>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>























