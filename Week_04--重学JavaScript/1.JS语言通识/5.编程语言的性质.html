<!--
图灵完备性
    命令式---图灵机
        goto
        if 和 while
    声明式---lambda
        递归

我们所有的编程语言它必备的一个条件，就是图灵完备性；
图灵完备性有几个不同的表达方式，比如说跟图灵机完全等效的就是图灵完备，当然了这个定义特别的不直观，它虽然很严格，但是它并不直观，我想如果给大家一个直观
的这样的表述，就是所有的可计算的问题都可用来描述的，这样的语言就是具备图灵完备性的，经历了一代一代的计算机语言的发展，其实图灵完备性逐渐地收敛到了几个
固定的模式，所有的命令式语言，基本上它是从图灵机理论来的图灵完备性，所以说它实现图灵完备的方式，要么是使用goto 语句，要么是使用 if 语句加 while 语
句，经过一些数学家的证明，goto语句 和 if 加 while，那么这两个模式都是可以实现完整的图灵完备性的，然后这个声明式语言，那么它来自于另一个数学家的成果，
叫做 lambda 验算，这是邱奇提出来的 lambda 演算，lambda 演算，你可以理解为它是数学上定义的一种所谓的 lambda 函数，它和我们今天的函数是比较相似的，
但它的基本的意思就是一种替换的关系，lambda 演算，那么它可以通过递归来实现图灵完备，然后这两位数学家其实都是在，很早的时间相继发表的成果，所以在可计算
性上面，基本上计算机语言也是有两个流派，一个使用goto、if 和 while 这个流派，另一个是用递归来产生图灵完备性，这两个方式在很多现代的语言里，基本上是两
者都支持，所以在使用的时候，判断它们的适用的场景，然后选择合适的方式去实现它。



动态与静态
    动态
        在用户的设备/在线服务器上
        产品实际运行时
        Runtime
    静态
        在程序员的设备上
        产品开发时
        Compiletime

动态你可以理解为，它一定是在用户的设备上面去运行的，或者是在在线的服务器上面去运行的，那么它的运行的时机，就是在产品实际的应用运行时，那么它在这个动态
它基本上对应了一个概念，叫 Runtime，Runtime 就是运行时，运行时的概念，反过来它也跟我们前面的两个场景，是非常的相关连的；
静态最显著的一个特征，就是在程序员的设备上运行的，它的时机也是在产品的开发时发生的事情，我们一般来说会把它称作静态，比如说静态类型检查，就是在你编写这
段代码的时候，你就已经可以获得类型的检查了，静态它通常也对应的一个术语，叫 Compiletime（ 编译时 ），编译时也是一个来自于非常古老的一些编译型语言的
这样的一个概念，从 C 时代就开始流行 Compiletime 和 Runtime 的这样的一种对应关系了，咱们像 Js 这种解释执行的语言，其实它没有 Compiletime，咱
们现在有的时候也会用 Webpack 去 build 一下，但是其实它是没有真正的 Compiletime 的，所以说，其实今天的 Compiletime 跟 Runtime 的对应，已经
不准确了，但是我们仍然会愿意沿用 Compiletime 的习惯，因为JavaScript，它也是有一个我们在开发时的这样的一个时间，我们也会有时候会用 Compiletime
这个词来讲 JavaScript 的里面的一些特性，所以这就是所谓的动态与静态的区分了。


类型系统
    动态系统和静态系统
    强类型与弱类型
        String + Number
        String == Boolean
    复合类型
        结构体
        函数签名
    子类型
    泛型
        逆变/协变

强类型和弱类型，常常与 静态和动态相混淆，但是强类型和弱类型，只是说明在编程语言里类型转换发生的形式，
强类型的语言，类型转换是不会默认发生的；

JavaScript 里面它就是一个典型的弱类型的语言，最著名的比如说，我们用一个String 和 一个 Number
相加，JavaScript 引擎会默认的把 Number 转换成 String 类型，最后给你得到一个 String。
像 == ，它是JavaScript 里面的一个臭名昭著的失败的这样的一个语言特性，它在 String 和 Boolean
之间，如果说你去做双等运算的话，它会先把这个 布尔 转成 Number ，然后再跟 String 去做是否相同的
对比，这是非常奇怪的一个设计。


{
    a:T1,
    b:T2,
}
(T1,T2)=> T3
然后再说类型，这往往会产生一些复合类型，比如说我们可以定义一个结构体，定义一个对象，那么它的 a 属性
它必须得属于类型 T1，然后我们有一些函数函数，因为像 JavaScript 语言，它函数是可以作为参数传递的，
所以这个函数也有个类型，这个我们一般把它称作函数签名，函数签名包含参数类型和返回值类型两个部分，参数
类型它又是一个列表，所以说函数类型它可能就会有 T1、T2，然后变成 T3 这样的一种形式。

然后就是子类型， 典型的语言就是 C++，它会有子类型的一个概念，当然了，所有的基于类的面向对象的语言，
它都会把类的结构关系变成类型的关系，注意类和类型其实是两个概念，那么有了子类型的这个概念，所以所那
么在做类型转换的时候，它就会有一些默认的行为，比如说能用父类型的地方，它都能用子类型，然后还有一种
是泛型，在一些语言里面现在又多了一种范式，叫做范型编程，还可以把这个类型当做一个参数一样的东西，去
传递给我们的某一段代码结构，然后才有可能这个代码结构有可能是类，也有可能是函数，分别对应着泛型类和
泛型函数，然后泛型和子类型相结合，就会产生逆变、协变这样的东西。
举个例子：
凡是能用Array<Parent> 的地方，都能用Array<Child>
凡是能用Function<Child> 的地方，都能用Function<Parent>

假如说我们的 Array 是一个接受泛型的这样的一个数组，那么凡是能用到它的 Parent 的地方，
它都能用到它的 Child，都能用 Child 的类型的数组去替代，也不管我们要对 Array 里面的
元素做什么操作，它都可以 Child 类型肯定继承了 Parent 类型所有的功能，这中称为协变。

如果说泛型的结构它是一个 Function，它接受 Child 作为参数，接受 Child 作为参数，一定
也能够去接受 Parent 作为参数，这样的函数，我们就可以把能接受 Parent 参数的函数传进去，
然后让它代替能接受 Child 的函数，这种称为 逆变。

泛型跟不同的类型系统的特征相结合，就会形成一个非常复杂的这样的一个类型的机制。



参考名词：
图灵完备性：在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完全的。
这个词源于引入图灵机概念的数学家艾伦·图灵。虽然图灵机会受到储存能力的物理限制，图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”。

图灵机（Turing machine）：又称确定型图灵机，是英国数学家艾伦·图灵于 1936 年提出的一种将人的计算行为抽象掉的数学逻辑机，
其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。

静态和动态语言： https://www.cnblogs.com/raind/p/8551791.html

强类型： 无隐式转换

弱类型： 有隐式转换

协变与逆变： https://jkchao.github.io/typescript-book-chinese/tips/covarianceAndContravariance.html
-->

