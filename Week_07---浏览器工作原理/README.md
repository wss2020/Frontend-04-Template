# Week_07 总结
推荐阅读：https://juejin.im/post/6874114366023663623
- **HTML 解析**
    - 第一步 HTML parse 模块文件拆分
        - 为了方便文件管理，单独把 `parser` 单独拆分到文件中
        - `parser` 接收 `HTML` 文本作为参数，返回一颗 `DOM` 树
    - 第二步 使用 FSM 实现 HTML 的分析
        - 使用有限状态机 `FSM` 实现 `HTML` 分析
        - 在 `HTML` 标准中，已经规定了 `HTML` 的状态
        - `Toy-Browser` 只挑选其中一部分状态实现，完成一个最简单版本
    - 第三步 解析标签
        - 主要标签：开始标签、结束标签、自封闭标签
    - 第四步 创建元素
        - 在状态机中，除了状态迁移，还需要加入业务逻辑
        - 在标签结束状态提交 `token`
    - 第五步 处理属性
        - 属性值分为：单引号、双引号、无引号三种写法
        - 属性结束，将其加到 `token` 上
    - 第六步 用 token 构建 DOM 树
        - 遇到开始标签创建元素并入栈，遇到结束标签出栈
        - 自封闭标签入栈后立刻出栈
        - 任何元素的父元素是它入栈前的栈顶
    - 第七步 将文本节点加到 DOM 树
        - 文本节点与自封闭标签处理类似
        - 多个文本节点需要合并
- **CSS 计算**
    - 第八步 收集 CSS 规则
        - 遇到 `CSS` 标签，使用 `CSS Parser` 收集相关规则
    - 第九步 添加调用
        - 当创建一个元素时，立即计算 `CSS`
        - 理论上，当我们分析一个元素时，所有 `CSS` 规则已经收集完毕
        - 在真实浏览器中，可能遇到写在 `body` 的 `style` 标签，需要重新 `CSS` 计算的情况，这里我们忽略
    - 第十步 获取父元素序列
        - 必须知道所有父元素，才能判断元素与规则是否匹配
        - 在 `stack` 中，可以获取到所有父元素
        - 因为首先获取的是当前元素，所以我们获得和计算元素匹配的顺序是由内向外
    - 第十一步 选择器与元素的匹配
        - 选择器也要从当前元素向外排列
        - 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列
    - 第十二步 计算选择器与元素的匹配
        - 根据选择器类型和元素属性，计算是否匹配当前元素
        - 代码中只实现了简单选择器：`id` `class` `元素名`
    - 第十三步 生成 computed 属性
        - 一旦选择器匹配，就应用选择器到元素上，形成 `computedStyle`
    - 第十四步
        - `CSS` 规则根据 `specificity` 和后来优先规则覆盖
        - `specificity` 是个四元组，越左边权重越高
        - 一个 `CSS` 规则的 `specificity` 根据包含的简单选择器相加而成
