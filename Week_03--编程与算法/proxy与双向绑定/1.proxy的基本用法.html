<!--
 proxy 是一种，强大且危险的设计，应用proxy 的一些代码，预期性会变差，所以 proxy 是专门为底层库，
 来去设计的这样的一个特性。
-->

<script>
    // 如果我们去访问object 的 a 属性和 访问 b 属性，这个中间，它其实是一个写死的这样的过程，
    // 我们没有办法在这个中间，加入任何监听的代码，这样的话，其实 object 就是一个不可 observe 的
    // 这样的一个对象，就是一个单纯的数据存储；这也是 javaScript 最底层的机制，我们是没有办法改变的。

    // 如果我们有一个对象，我们既想要去让它设置起来，像一个普通对象一样，又想让它能够被监听，那么我们怎么办？
    //我们就可以通过一个 proxy 来把它这个 object 去做一层包裹。
    // 那么我们接下来就创建一个 proxy ，

    let object = {
        a: 1,
        b: 2
    }

    // 我们创建一个proxy ,第一个我们要把这个 object 传进去，
    // 第二个对象是一个 config 对象，这个config 对象里面就包含了所有的，我们要对po对象
    // 去做的钩子，我们这里做一个最简单的钩子 set;
    // 当我们去设置对象的一个属性的时候，它就会触发我们的set函数，我们来看一下，
    let po = new Proxy(object, {
        set(obj, prop, val) {
            console.log(obj, prop, val);
        }
        // 这里可以做测试， 调用 po.a = 3, 看会输出什么；
        // 如果po 是一个普通对象的话，那么它任何代码都不会去执行，除非 a 是一个 setter,
        // 但是在 proxy object 上，那么我们就，不管去设置哪一个属性，
        // 那么它都会得到一个不一样的值；

        // 然后我们如果设一个 po 上没有的属性， 我们看到它跟 getter setter ，最主要的
        //一个区别，就是 proxy object 上，即使我们设置一个没有的属性，它也会默认触发这个
        // set 的值。

        // 我们的这个 proxy 不止提供了， get set 属性的这样的钩子，那么我们有很多原生
        // 的操作，或者内置函数对对象的操作，它都提供了一个，可以拦截它并且改变它行为的这
        // 样的一个东西。

        //这里 object 收到的就是 proxy 这个被代理的对象，实际上，你去调用原始的 object，
        // 去设置它的值，并不会触发 proxy 上 hook 的这些函数。
        // proxy 在，只有 po 那么才会最后去执行到 proxy 对象的行为，
        // object 还是原来的 object 。
        // 所以说，可以把 po 理解成一个特殊的对象，po这种对象，那么它上面所有的行为，
        // 都是可以被重新再去指定的，所以说一开始的时候会去讲，这个 object 在使用了
        // proxy 之后，对象行为的这种可预测性会降低。
        // 也就是说，你看到了一个代码，  po.a = 3, 也许它后面就做了一系列很复杂的操作。
        // 那么你本身是不会知道这件事情的，所以说 proxy 这个特性，是一个非常危险的特性。

        // 我们这里展示了 set ,那么还有 getPrototype 什么，这都可以通过我们的 proxy 的
        // config 去改变它的行为。


    })
</script>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
