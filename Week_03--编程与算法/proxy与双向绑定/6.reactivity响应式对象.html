<!--
   接下来我们来考虑一下， 这个reactive 有什么用？
   它是一个半成品的双向绑定，它可以负责我们的 从数据到我们的 DOM 元素的这一条线的监听，
   从 DOM 元素到数据的这一条线的监听，其实很简单，因为 DOM 元素本身就有事件，
   然后它也不一定是到 DOM 的元素，它可以是任何的 native 的输入，它都可以去代理到这个 reactive 里面。

   接下来考虑一个实际的例子，我们给这个页面加一个 input ,我们可以把它这个 object ,再重新再改写一下;
   那么我们给它创建了 effect 之后，我们给它一个单向的这样的绑定， 从数据 到 input ，document.getElementById('r').value = po.r;
   这样的话，我们按照我们的现在的知识结构，effect 就会自动地让我们的 po.r 变的时候，input 的值跟着变，
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
     <input  id="r" />
</body>
</html>
<script>
    // input 输入框，到数据的监听    从 DOM 元素到数据的这一条线的监听
    document.getElementById("r").addEventListener('input',event=> po.r = event.target.value);


    let callbacks = new Map();
    let reactivties = new Map();

    let usedReactivties = [];

    let object = {
        r:3
    }

    let po = reactive(object);

    effect(() => {
        document.getElementById('r').value = po.r;
    })

    function effect(callback) {
        usedReactivties = [];
        callback();
        console.log(usedReactivties);

        for (let reactivity of usedReactivties) {
            if (!callbacks.has(reactivity[0])) {
                callbacks.set(reactivity[0], new Map());
            }
            if (!callbacks.get(reactivity[0]).has(reactivity[1])) {
                callbacks.get(reactivity[0]).set(reactivity[1], []);
            }
            callbacks.get(reactivity[0]).get(reactivity[1]).push(callback)
        }
    }

    function reactive(object) {
        if (reactivties.has(object))
            return reactivties.get(object);

        let proxy = new Proxy(object, {
            set(obj, prop, val) {
                obj[prop] = val;
                if (callbacks.get(obj))
                    if (callbacks.get(obj).get(prop))
                        for (let callback of callbacks.get(obj).get(prop)) {
                            callback();
                        }
                return obj[prop];
            },
            get(obj, prop) {
                usedReactivties.push(obj, prop);
                if (typeof obj[prop] === "object")
                    return reactive(obj[prop]);

                return obj[prop];
            }
        })

        reactivties.set(object,proxy);

        return proxy;
    }



</script>


