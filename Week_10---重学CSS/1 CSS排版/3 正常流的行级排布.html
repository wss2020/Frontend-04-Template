<!--
Baseline
    基线对齐
    全世界各国的文字，它其实都是有一条基线对齐的规则，但是不同的国家，它其实依赖的基线
的位置不一样，比如说中文要是跟它混排呢？那么中文可能要在基线的基础上，产生一个偏移，一般
来说我们认为中文叫方块字，我们这样中文的这种字形呢？它都是会以文字的上缘和下缘，去作为
基准线去对齐的，但是这不妨碍，我们也认为中文，它是基于 baseline 对齐的，只是它带了
一定的偏移，这是基线的概念。
-->


<!--
Text
    一个字形它是怎么样去定义的，其实我们的一个文字，咱们在更早讲 JavaScript 的
时候，已经给大家讲了一些字符字符集，这方面的基础知识，而这个字符，它其实是一个它就
是一个码点，它具体的形状，是由咱们的字体来决定的，这里我找了两张图，这两张图不是我
自己画的，它是来自于一个著名的 C++ 的底层库，叫做 freeType ,它就是处理各种字体
文件，做抽象的这样的一个库，一个开源界大部分的软件，都会去使用的一个这样的字体库，
它就从字体文件里头，抽象出来的这样的一个定义，而任何一个文字，它其实都是有一个宽
和一个高，除此之外，它还有一条基线的定义，如果没有这条基线的定义，咱们的字体是不
成立的，最后你没有办法，
    去用它进行排版，比如说我们看到，它这里面这个 origin 原点，它所标识的位置，
其实就是咱们的文字的基线的位置，它其实是以基线的原点，作为一个坐标，然后来定义
这个文字的位置，那么所以说基线，它认为这就是 X=0；
    然后它有一个 xMax 和一个yMax ,
    那实际上在这张图里面 yMin 的相反数，就是咱们的基线到字的底缘的距离，
    然后它会有一个 bearing ,bearingX 决定了一个默认的一个字间距，
    然后advance 就是这个字符串整个占的空间，我们虽然说有文字的地方，它被标识
为了 width ，但如果我们要去做排版，那么实际上它一个字占的空间，是一个advance
这样的一个空间。

    纵排其实它又有另一套这样的逻辑了，所以说这是在底层的软件定义的字形的一个概念，
我们在这里也需要去理解一些文本，这样的基础概念，然后我们才能知道，什么叫做文本跟盒
的混排。
-->


<!--
行模型
    有了上面的基础之后，我们看一下CSS 里面的行模型，这里我们重点讲5条线，其实还有
一些其他的线和位置，就是什么 sub sup ,这个我们不去讲了。

    这个base-line 和文字的顶缘和底缘，分别叫做 base-line 的 text-top 和
text-bottom ,这两条绿线和一条橙色的线，base-line 刚才已经讲过了，主要是以
英文为主，用来对齐的这条线，
    然后这里面有一个 text-top 和 一个text-bottom，你要你字体的大小不变，
text-top 和 text-bottom 是不会变的，如果你用了多种不同的字体混排，那么
text-top 和 text-bottom 是由 fontSize  最大的一个字体决定的，
    然后文字的上缘和下缘它其实基本可以理解为，是两条固定的线，另外如果说行高，
是大于文字的高度的时候，它还会有 line-top 和 line-bottom 两条白色的线，
    如果说我们只有文字的话，那么行模型也就这样了， 然后再加上点 sub sup ,
这些比较稀有的位置，就可以了，但是我们一旦涉及到了跟盒的混排，它就设计到一个，
line-top 和 line-bottom 的偏移的问题，
    当我们的盒足够大的时候，比如说我们的盒是从 text-bottom 去对齐的，那么它就
有可能把高度撑开，这个时候 line-top 就从虚线的位置，移到了白色的实线的位置，这
个现象就是正常流里面，处理行模型非常麻烦的一个现象，盒的先后顺序和盒的尺寸，都会
影响 line-top 和 line-bottom 的这个位置，但是盒是不会影响 text-top 和
text-bottom.

-->

<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<div style="font-size: 50px;line-height: 100px;background-color: pink;">

    <!-- 占空间极小的元素 -->
    <div style="vertical-align: top;overflow: visible;
                display: inline-block;width: 1px;height:1px;">
        <div style="width: 1000px;height: 1px;background: red"></div>
    </div>

    <span>Hello good 中文</span>
    <div style="
    vertical-align: text-bottom;
    line-height: 70px;width: 100px;height: 70px;
    background-color: aqua;display: inline-block;
">

<!--        b-->
        b</br>c
    </div>


    <!--  再复制一个 b c  -->
    <div style="
    vertical-align: text-top;
    line-height: 70px;width: 100px;height: 150px;
    background-color: aqua;display: inline-block;">
        b</br>c
    </div>

</div>

<!--
    执行代码，我们发现，它默认是一个基线的对齐的规则，所以说它用盒的下边缘，跟文字的
基线去做了对齐，
    但是一旦这个里面，我们加了一个文字 b，我们就发现,它的基线的位置就变了，它的基线
变成了它里边文字的最后一行的基线，
    如果我们再加一个 c ,它就变成了下一行，所以这个是第一个，需要特别注意的问题，
就是行内盒 inline-block 它的基线，是随着自己里面的文字去变化的，所以说其实大
部分情况下，我是不建议，大家给行内盒使用基线对齐的，我们可以使用，给它一个
vertical-align ，我们一般会给它一个，vertical-align 设为 top ,或者是
bottom ，或者是 middle ,
top 那么就是跟行的顶缘对齐，我这里给的这个行是一个 100px,它会把这一行撑开，
    如果我们是给的是底缘对齐，那么它就会从下面把它撑开，
    如果我们给的是一个 middle ,那么它就会在中心线跟文字去对齐，
这是几种最基本的模式。
    然后它还可以跟 text-top 和 text-bottom 去对齐，然后它一样会把上边缘
和下边缘撑开，
    然后这个时候我们可以看一下，这里我们用了一个小技巧，我们用一个div ，占空
间极小的div ,然后我们给它设置了一个，里面有一个很长的元素，然后这样我们就可以
画出来，这条对齐的线，然后我们先看看中心线，这个时候，中心线在这个红色的线的位置，
它是穿过了整个文字，我们可以看到虽然 line-top 和 line-bottom 已经被撑开，
但是 middle 的中心线实际上是没有变的，
    但是top 的线已经发生了变化，可以把 占空间极小的div 的 vertical-align: top;
查看效果，它的top 线已经被撑开了，所以只有 top 和 bottom 这两条线是会被撑开，有这个
位置变化的，
    然后我们看看，其实我们是可以有两个元素，分别撑开 top 和 bottom 的， 再复制一个 b c,
我们可以看到，这个位置是它的顶部和底部，分别有两个元素把它撑开，然后实际上，没有任何一个元素
的高度是，等于整个的行高的，  因为我们不同的 align 导致它被撑开。
    关于行模型，就讲到这个，实际上整个的 vertical-align ，对整个行的高度的影响，还是比较
多的，而因为top 和 bottom 是随着行的撑开而变化的，所以其实行模型，我们之前在 toy-browser
里面，已经实现过 flex 的行模型，那个相对来说，它就只需要去考虑最高的一个元素，但是在咱们的正常
流里面，行模型还是比较复杂的，如果我们真的要去在 toy-browser 里面，去实现这个正常流的行的排布，
我们写的代码要比 flex 还是要更复杂一些。

-->









