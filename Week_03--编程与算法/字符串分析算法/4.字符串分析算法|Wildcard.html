<!--
Wildcard 比起前面的 case 来所，它是一个比较复杂的情况，因为加入了两种通配符，所以说它让我们的字符串的匹配，变得没有那么的可控。

Wildcard：  ab*c?d*abc*a?d
     只有* ：ab*cd*abc*a?d
     只有？：c?d, a?d

要解 Wildcard 这个问题，首先需要简化一下这个问题，一开始考虑 既带 * 又带 ？的情况，我们是不好匹配的。
那么我们先考虑两种情况，第一种情况就是只有星号的情况；第二种情况就是只有问号的一种情况。

先分析只有星号的情况：
ab*cd*abc*a?d
假设只有这样的一个只有星号的模式串 ab*cd*abc*a?d ，那么在这个模式里面，我们会发现，它不同的星号，会稍微
有一些不同，首先来想一想，因为星号它是这里面，不确定性最高的一种符号，星号到底应该尽量匹配的多，还是应该尽量
匹配的少呢？
结论： 其实最后一个* ,和前面的* 是不一样的，因为最后一个* ，可以尽可能地匹配多个字符，
      而不管前面剩了多少字符，那么最后一个星号，它其实都可以匹配到，因为星号是一个可以
      无限长，不管你匹配什么字符都可以，所以在最后一个 * 之前的所有的 *，也就是这个例子
      的所有的 白色的星号（ *cd*abc  ）；它是可以尽量少地匹配的，而在这张图里，那个橙色
      的星号 （第三个星号），他是要尽量多匹配的，除了最后一个 * ，所有的白色的星号，它都是
      尽量地少匹配，那么此外，整个的模式里面，还有两个特别的段，一个是 ab 这一段，就是开头的
      这一段，还有一个是 ad 这一段，结尾的段，绿色部分，那么它只匹配开头的几个字符，蓝色部分，
      就是最后一个橙色的星号后面的部分，它只匹配尾巴上的几个字符，这个是 Wildcard 里面比较
      特殊的； 剩下的中间的白色，不管它有多少段，这个星号，相当于一个 * 加上一段字符作为一组，
      那么一个星号，加上一个字符是什么意思？
       就是我在这个字符串里面，去找一个特定 pattern 的字符，这个其实就是咱们，前面讲过的KMP算法。
       这个 *，匹配cd ,那么它就是在这个字符里面，找cd 字符，这个abc 就是在这个源字符串里面，去找
       abc 这个字符；
       如果我们去掉问号，那么一个 Wildcard，其实它就是若干个 KMP,来组成的这样的一个格式，那么如果
       我们加上问号，我们可能要写一个比较复杂的算法，带问号的 KMP,但是这个带问号的 KMP 有点复杂，
       所以我们这个地方偷个懒，我们发现在一个字符串里，找一个特定的 pattern ,除了 KMP 算法，还有什么
       办法，咱们前面也讲过 正则（表达式）的 exec 也可以帮助我们，去解决这个问题，如果我们把一个整个
       Wildcard 整个转换成正则（表达式），那么它的性能一定是不合格的，但是我们通过追段地转换成 exec
       我们去处理正则（表达式）的话，那么它的性能就没有什么大的问题。

       接下来，看代码
-->
<script>
    // 我们要想知道，最后一个星号，首先我们至少要知道它有几个 *，因为我们从前到后只扫描一遍，我们是不知道哪个星号是最后一个星号，
    // 所以说，我们会有一个算法，从头到尾的去找，它到底有多少个星号，

    function find(source,pattern){
        let starCount = 0;
        // 所以我们的第一段循环，就是循环访问整个的 pattern 字符串，找出来有多少个星号，
        for(let i=0; i<pattern.length; i++){
            if(pattern[i]==="*"){
                starCount ++;
            }
        }
        // 这里处理边缘 case ,没有星号的情况，就是这个字符串跟 pattern 严格的一一匹配，除了问号，问号是可以匹配任何字符的，
        // 其它符号，那么我们都给它直接就过去，一个一个的比，不一样的话那就是不匹配，一样的话就是匹配，
        if(starCount==0){
            // 写一个算法，循环访问整个的 pattern ，
            for(let i=0; i<pattern.length; i++){
                if(pattern[i] !== source[i] && pattern[i] !== "?"){
                    return false;
                }
            }
            return
        }


        // 上面处理完边缘 case 之后，
        let i =0;
        let lastIndex = 0;

        for(i=0; pattern[i] !== "*"; i++){
            if(pattern[i] !== source[i] && pattern[i] !== "?")
                return  false;
        }

        lastIndex = i;

        for(let p = 0; p<starCount -1; p++){
            i++;
            let subPattern = "";
            while (pattern[i] !== "*"){
                subPattern += pattern[i];
                i++;
            }

            let reg = new regexp(subPattern.replace(/\?/));
        }

    }
</script>





<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
