<!--
字符串分析算法

字典树：
    大量高重复字符串的存储与分析
KMP：
    在长字符串里找模式
Wildcard:
    带通配符的字符串模式
正则：
    字符串通用模式匹配
状态机：
    通用的字符串分析
LL  LR:
    字符串多层级结构分析

顺序从简单到难

字典树：用来精确的匹配字符串跟模式，去看一个字符串，它是不是能够两个字符串，能否精确相同的。
       处理大量高重复字符串的存储与分析的问题，比如我们要处理 1亿个字符串，这里边有多少出现（频率）前50的字符串

KMP: 不是一个完整的字符串匹配算法，它是一个检查一个长字符串里面，有没有一个短字符串的部分的，它是一个部分匹配。
     它跟字典树最大的区别，就是字典树是检查两个字符串是否完全匹配， KMP 它是两个字符串，一个字符串是另一个字符的部分。
     他的问题就变得更复杂了，那么KMP 如果我们去想一个，长度为 m 的字符串，和一个长度为 n 的字符串，那么他俩互相匹配，
     而我们用一个最笨的办法，它可能是一个 m 乘以 n 的时间复杂度。
     但是有几位计算机专家，KMP 是三个人的名字的首字母，K 是高德纳，最著名。
     它的算法可以做到 m 加 n,很厉害。

Wildcard:在 KMP 的基础上又加了通配符，通配符就是会有 ？，然后会有 *，
         ？ 表示匹配任意字符， * 表示匹配任意数量的任意字符，
         比如，我们在做一些文件查找的时候，可能就会用到 Wildcard 的这种通配符的形式，
         可以理解为，它是一个弱一点的一个正则（表达式）。
         然后因为，它只有两种通配符，而这个通配符，它跟正则（表达式）有一个显著的区别，
         就是 Wildcard 其实也是可以在，O(n)的时间复杂度内去处理掉的，或者是O(m + n)的这样的一个规模去处理掉的；
         这有一个贪心算法，所以说 Wildcard 也是一个非常神奇的这样的一个东西。

正则：正则一般来说，是一个需要用到，回溯的这样的一个系统，那么它可以说是，字符串模式匹配的，这样的一个终极版本。


以上都是字符串的模式匹配。

状态机：是一种比正则（表达式）更强大，正则（表达式）跟有限状态机呢，理论上是完全等价的两种东西，
       但是有些状态机不同的是，你还可以往里面嵌代码，你还可以去对字符串做额外处理，但是区别就是
       正则（表达式）写起来很方便，有限状态机写起来，它的成本比较高，还需要一定的设计，然后在简单的匹配
       和分析的基础上，要对字符串建立起来多层级的结构，我们就会使用 LL 和 LR 这样的语法分析的算法。

LL 已经讲过，lR呢，实际上LR 是一个比 LL更强大的一个语法分析，但是通常我们简单写，就都用LL去写，
因为LR它的理论性比较强。

其实我们前面讲过HTML的语法分析，我们用了一个 stack 去处理，它其实就是一个 LR 算法的一个简化版，
它其实是一个 LR（0）的语法，但是一般来说，我们去处理都会用LR（1），LR（1）一是可以等于到LL（n）的，
这样一种非常强大的分析算法。因为在咱们的课程里，不想过多地涉及编译原理的内容，所以我们就，不再去重复地
去讲解了。

-->




<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
