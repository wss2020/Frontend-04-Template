<!--
在咱们正式去实现浏览器之前，首先需要讲一个基础知识，叫做有限状态机处理字符串，因为这个处理字符串，
是咱们整个 browser 里面贯穿始终的这样的一个技巧，所以说如果说咱们不会用有限状态机，后面会很吃力，
对于读这个代码，所以咱们单独讲一讲  有限状态机去处理字符串。

有限状态机
    每一个状态都是一个机器
        在每一个机器里，我们可以做计算、存储、输出......
        所有的这些机器接受的输入是一致的
        状态机的每一个机器本身没有状态，如果我们用函数来表示的话，它应该是纯函数（无副作用）
    每一个机器知道下一个状态
        每个机器都有确定的下一个状态（ Moore ）
        每个机器根据输入决定下一个状态

有限状态机在咱们一些程序员，也包括作者，它的日常表达中有时候就说转态机，状态机处理字符串，其实有限
状态机它并不对应这一个无限状态机的这样的一个概念，所以有时候把有限两个字省略，那么也还是不错的，有
限状态机它的学术化的定义非常的复杂，所以这里我希望通过我自己的一个感受，给大家感性的描述一下有限状
态机。
    首先，有限状态机，它的重点在机上，不在状态两个字，有些同学问，咱们平时都会用代码来代表状态，
咱们的面向对象的设计模式里又有所谓的状态模式，其实虽然都用了这个状态一词，但是状态机这个状态跟他们，
在概念上差异是比较大的，有限状态机他最大的一个特点就是每一个状态都是一个机器，我们之所以会希望用有
限状态机去处理一些编程问题，就是因为有限状态机里的每个机器都互相解耦的，正因为这种每个状态是一个独
立的机器的这样的一个思想，让我们的有限状态机变成了一个非常强有力的抽象机制，在有限状态机的每一个机
器里，我们都可以做计算、存储、输出。。。  这就意味着我们编写状态机的代码的时候，我们可以完全忽略
其它状态机里面的逻辑，只关系本状态我们要处理什么问题，比如说 我们的状态机有一个广泛的应用，就是在
游戏里，这个游戏里经常用于敌人的 AI , 很多时候，当我们的主角不跑进敌人的注意范围的时候，敌人是不
启动的，这个时候我们就完全可以用状态机来区分，攻击状态和等待状态，在等待状态，敌人只需要关心，主角
是走进我的攻击范围，这样一件事就可以了，而在攻击状态，则需要关心更多的，比如说我们的主角是否已经
跑得足够远，我们的主角是否仍然有技能在打他等等，这样的一些逻辑，我们在静止状态的敌人，他的状态非常
地容易编写，它运行起来消耗的资源也非常的少，这是不是状态机能够为我们简化的逻辑；
    状态机里面有一个特点，既然每个机器都代表一个状态，所以说这些机器他所接受的输入是完全一致的，
我们不能说这个状态它能接受一个字符串，那个状态它能接受一个整数，这样是不行的，要么就都接受字符串，
要么就都接受整数，当然了你也可以选择让两个状态都变成，既能接受整数，又能接受字符串；
    状态机还有一个特点，就是状态机的每个机器本身是不能再有状态的，如果咱们用函数来表示的，状态机
里的所有的这些函数是纯函数，他不能有副作用，当然了，如果是针对其他的，如果说我们去输出，比如说我们
去改变变量，这个不属于副作用，这里指的副作用是指 这个机器它不应该再受外部的输入控制，输出是可以的，
所以我们的状态机里面，如果我们用函数来表死状态机，等一下我们就会用到这个技巧，我们用函数来表示状态
机的每一个机器的时候，我们可以往外写，但是不能从外边再读变量进来了，一旦读了，再影响了这个状态机本
身的状态切换逻辑，它就会出现很大的问题；
    状态机的另一个重要的特点就是每一个机器他都必须知道自己的下一个状态是什么，在经典的有限状态机的
理论里有两种状态机，一种叫做 Moore 状态机，Moore 状态机是一种简单的状态机，每一个机器他都有确定
的下一个状态，也就是说我从状态 a 不管接受什么样的输出，他一定可以进到状态 b ，状态 b 不管接受什么
样的输入，它一定会进入下一个状态 c ,以此类推，当然了它也是可以有循环的，比如状态c 可以回过来回到
状态b 或者 状态a ,不论如何呢，这个状态回到那，是由程序员在编写状态机的代码就已经决定好了的，而不是
受它的输入影响可以做分支的，这种状态机叫做 Moore 型的状态机；
    而如果每个机器他是根据输入决定下一个状态，这种状态机就叫 Mealy 型的状态机，Mealy 型的状态机
是咱们大多数时候比较实用的一种状态机，他接受不同的输入，就可以进入到不同的下一个状态当中，这种强大带
来了一定的代码的复杂性，但是同时也带来了非常强的表达能力，到这里，我是以我的感受来给大家描述一下有限
状态机，下一步我来给大家介绍一下，状态机具体在 JS 中会怎么样去实现。
-->

<!--
JS 中的有限状态机 （Mealy）
// 每个函数是一个状态
function state(input)    // 函数参数就是输入
{
    //在函数中，可以自由地编写代码，处理每个状态的逻辑
    return next;   // 返回值作为下一个状态
}

//////// 以下是调用 ////////
while (input){
     // 获取输入
     state = state(input);  // 把状态机的返回值作为下一个状态
}

介绍一下 JS 中实现 Mealy 型的有限状态机，其实说起来有点复杂，但是实现起来是非常地简单的，咱们就用
每一个函数来表示一个状态，然后函数的参数就是输入，而这个函数的返回值就是下一个状态，在函数中可以自由
的编写代码，处理每个状态的逻辑，返回值是下一个状态，就意味着我们的下一个返回值一定得是一个函数，这个
函数还必须得是一个状态函数，状态函数就是咱们刚才讲的，这状态函数它接受 return 返回下一个状态，所以
你可以认为在 JS 中状态机的一个理想的实现方式，就是一系列返回状态函数的这样的一批状态函数，在调用的时
候，我们往往会用一个循环来获取输入，然后通过 state = state(input) 这样的一种调用方式，来让状态机
接受输入并且完成状态切换，这样 state 变量就是永远表示当前状态，然后不管你用什么方法获取了一个input
之后，它就会发生一个状态迁移，并且完成每个状态中所需要完成的计算，Mealy 型的状态机，只有return
几乎一定是根据 input ,去在一系列的 if else , 或者 switch case 里面；
如果是 Moore 型状态机，return  跟 input 无关，他就是返回一个固定的状态，咱们空口说可能大家还是
不够理解，所以在接下来我会以一系列的实例来给大家讲解这个状态机。


-->














<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
