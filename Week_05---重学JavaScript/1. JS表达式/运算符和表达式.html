<!--
JavaScript
    Atom
    Expression
    Statement
    Structure
    Program/Module


Atom
    Grammar                                      Runtime
        Grammar Tree vs Priority                     Type Convertion
        Left hand side & Right hand side             Reference

这节课主要学习的知识是语法树跟运算符优先级的关系，以及运算符的左值和右值的这样的一个区别，
关于运行时我们会讲到类型转换和引用类型两个新的知识。

Grammar
    Tree vs  Priority
        + -
        * /
        ()
    首先我们来讲一下语法树与运算符优先级的关系，从小学就知道，乘除优先级把加减要高，然后
 如果说你实在想改变它们的运算顺序，还可以加括号，括号的优先级比乘除更高，所以当我们去构造
 一颗语法树的时候，我们必须要考虑到这个因素，乘除会优先形成更小一级的语法结构，然后加减它
 就会形成更高一级的这样的语法结构，比如说我们的 1+2*3 ，它就会形成咱们的图上的这样的一个
 结构2x3是一颗子树，然后1加上2x3的结果是这个的语法结构，我这颗树画的并不眼睛，它并不是一
 个抽象语法树，它是一个所谓的中缀树，但是其实它大概可以说明我们的运算符优先级会影响到语法树
 的构成，在JavaScript 的标准中，它是用产生式来描述运算符的优先级的。

 Expressions
    Member                  New
        a.b                     new Foo
        a[b]
        foo`string`
        super.b
        super['b']
        new.target
        new Foo()
    例子： new a()()       new new a()
    首先运算符优先级最高的是 Member 运算， Member 运算它的典型代表就是a.b这样的一个结
 构，但是虽然说叫做 Member 类的运算符，但是其实它也不完全是 Member，它就是一个分级的一个
 名称，那么 Member 运算也就是点运算符，只是它其中的一个代表，事实上在 Member Expressions
 语法结构中，一共可以出现几种不一样的表达式的方式，a.b 这个是成员访问，a[b] 也是成员访问，
 它们两个的区别就是 b 要不要是一个字符串，像 JS 这样的语法，用中括号里面写 b 的这种形式，
 它就是可以支持运行时的字符串，如果咱们换成比较静态的语言，它就不会允许你传一个变量进去这个
 位置；
    然后 Function ，我们之前讲过反引号的字符串，那么它的前面如果说加一个函数名，那么它会
 把这个反引号的字符串部分拆开，然后传进这个函数当作参数，这个运算它的优先级也是较高的，跟
 Member 运算是属于同一级，当然了这个运算其实跟 Member 没有任何关系了；
 另外一使用 super关键字，这个是只有在我们 class 的构造函数里面可以用 super 关键字，
 super 关键字，super.b和 super[b]，这种都属于 Member 运算，优先级跟变量名和变量方括号是一样的，
 此外 new.target 用法，new.target 的两前后两个词都是固定的，一个字都不能换，这个用法也是一个跟
 Member 运算优先级一致的，还有一个看起来非常不可思议，带括号的 new ,它的优先级跟咱们前面的这些是
 相同的; 然后不带括号的 new 被单独的设为一个优先级，称作 New Expression ，new 表达式，为什么要
 这样设计；
 其实我们会发现有一个 case: new a()()， 比如说我们 new 之后，new a 后面跟了两对括号，那么 a 后边的第一对括号到底
 是一个函数调用，还是一个 new 运算的结果，在我们的 Member 表达式里边，包含了 new 括号的情况下，这个结果就非常清晰，
 因为new () 的结构的优先级更高，所以说第一段括号一定是跟着前面new 运算的；
 为什么要有后边的所谓的 new foo，不带括号的要优先级更低，那么同样是有一个case:  new new a(), 我们连续写了两个 new,
 后边跟了一个 class 名 a,后面跟了一个括号，因为带括号的 new 它的运算的优先级更高，所以它的括号会跟第二个 new 优先级结
 合。
-->

<!--
Reference  引用类型
    Object            delete
    Key               assign
    介绍一个运行时的一个设施，因为我们的 a.b 它访问了一个属性，但是它从属性取出来的可不是属性的值，它取出来的是一个引用，
 引用类型并不是 JS 的7种基本类型之一，7种基本类型上一节课已经讲的很清楚了，但是引用类型它也是个确确实实的存在于运行时中
 一个 JS 的类型，这种我们把它称作标准中的类型，而不是语言中的类型。
    一个 Reference 它分为两个部分，第一个部分是一个对象，第二个部分是一个 key,我们前面讲过对象当然就是 JavaScript 的
 对象，我们前面讲过 key 可以是 String 也可以是 Symbol ，一个 Reference 类型，取出来的是一个 Object 和 一个key,
 所以说他就完全的记录了，Member 运算的前半部分和后半部分，那么 delete 和 assign 这样的基础设施，它其实就会用到 Reference
 类型，如果我们做加法或者减法的运算，我们就会把 Reference 直接解引用，然后像普通的变量一样去使用，但是 Member 表达式出来的，
 如果是放在 delete 之后，那么我们就需要用到引用的特性，因为我们要知道删除的是哪一个对象哪一个key,assign 也是一样，当我们进行
 赋值的时候，也就是说当我们把 Member 运算，放在一个等号的左边，当然了加等于 减等于 乘等于 除等于 这类的，还有 assign 运算都
 是一样的，我们把它放在左边的时候，我们也同样要知道，我们把右边的这个表达式赋值给哪一个对象的哪一个属性，这就是引用类型的一个关键
 的特征，我们的 JavaScript 语言就是用引用类型在运行时来处理删除或者是赋值这样的写相关的操作的。
-->

<!--
Expressions
    Call
        foo()
        super()
        foo()['b']
        foo().b
        foo()`abc`
        例子：   new a()['b']
 这里我们要介绍的是 Call Expression 函数调用，Call Expression 同样它是一个统称，最基础的 Call Expression 就是，一个函数后边跟了一对圆括号，
它的优先级要低于 new ,同时也低于前面的所有的 Member 运算，但是在括号之后，如果加上取属性，比如说方括号，比如说 .b  又比如说反引号，那么它会让表达
式降级为 Call Expression ，也就是点运算它的优先级也降低了，所以在这个地方多一句嘴，我们的语法结构能够表达的内容是要多于 运算符优先级所能表达的像这
种点运算， 它本身就可以有不同的优先级，它是它前面的语法结构来决定自己的优先级，你看带圆括号的属性，那么它的优先级就比这个不带圆括号的要低两级，所以有
时候我们用优先级来解释运算符，其实它并不是一个非常严谨的一种说法，真正严谨的还是使用产生式，一级一级的语法结构，来描述运算的优先顺序，这里我们还有一个
例子： new a()['b']  ， 圆括号是先跟a 结合，再跟new,    还是先跟 new 结合。
      答：显然这里是一个应该跟new 相结合，这个圆括号是 new 带来的圆括号，为什么，因为带圆括号的 new 它是一个 Member Expression ,它的优先级
      要高于Call Expression ，同时后边的带方括号的属性访问，它也因为被圆括号，被 Call Expression 拉低了优先级，所以说它的优先级也变低了，所
      以正确的理解方式是 new 出来了一个 a 对象，然后访问它的 b 属性。

这个部分其实你可以理解为 Call New 和 Member ，这三个它其实是原本应该是级别差不多的，我们是因为要处理 new 的后面的圆括号，跟谁结合的问题，所以才
产生了三个不同的表达式的优先级。
-->

<!--
Expressions
    Left Handside & Right Handside
        例子： a.b = c;     a + b = c;

这里我们来讲讲左手和右手运算，我们可以使用 a.b = c;  但是我们不可以使用 a + b = c; 为什么？
答：因为 a.b 它是一个 Left Handside Expressions , a+b 它就是 Right Handside Expression ，只有 Left Handside Expressions 才有资格
放在等号的左边，这个是一个各种编程语言都会使用的一个概念，所以在 JS 里面其实并不会定义所谓的 Right Handside Expression ，因为所有的Expression
默认它只要不属于 Left Handside ，它就一定属于 Right Handside, 所以我觉得这个地方要给大家讲一讲 Left Handside Expressions 到底是怎么来的，
他就是根据能不能够放在等号左边来的，所以如果大家有自己读标准的话，一定会对这个名字有一定的疑惑，这里我们给大家解答了。

Update
    a++
    a--
    --a
    ++a
    例子：   ++a++      ++（a++)
接下来我们来看看不能够放到等号左边的，从 Update Expression 这一级开始，它就已经是 Right Handside Expression, 我们可以认为Left Handside
Expressions 几乎一定是 Right Handside Expression 在 JS 里面没有例外，在大部分的语言里面也没有例外，Right Handside Expression 它是从
Update Expression 开始的，update 就是自增自减，假如说我们写了 ++a++ 的话，那么它所表示的是这个，a 是会优先跟后边的自增相结合的，大家要注意语
法现象，所以最后的结果它是不合法的，当然这个地方大家也不用特别去记 语法上它是不合法的，运行是不论他们两个谁先，最后都是不合法的。


Unary
    delete a.b
    void foo()
    typeof a
    + a
    - a
    ~ a
    !a
    await a
这里我们看看单目运算符 Unary Expression 。
单目运算符最典型的就是 delete ,这个上面有提到了，它后边就必须得是一个 Reference 类型才能够生效；
然后也是咱们前面提到过，咱们前面讲 Undefined 的时候有提到过 void 运算符，void 运算符的作用是把，后面不管是什么东西都给它变成 Undefined,这个
运算符看似没用，但是其实它类似于我们的空白，类似我们的回车，它可以起到很好的改变与语法结构的作用，也不能说完全没有用；
另外就是 typeof ,typeof 也是一个单目运算符；
然后是正号 和 负号，正号并不会改变后面的表达式的值，当然了如果后边是一个字符串的话，它就会发生一些类型转换，其实大部分的运算它都会发生一些类型转换，我
们的表达式可以说是类型转换的大户和重度用户；
~ 是一个位运算，那么它的把一个整数按位取反，如果不是整数呢？那么它就会把它强制转为整数；
然后非运算，那么它是一个针对布尔型的运算，所以我们有时候会用两个叹号两个非，然后来把一个数字，来把一个任何类型的数，强制转换成布尔类型；
另外 await 它也是一个单目运算，但是 await 其实还是有点复杂的，await 会对后续的语法，会对更大的语法结构，造成一些影响，


Exponental
    **
    例子： 3 ** 2 ** 3      3 ** （2 ** 3）
这里介绍一个非常奇特的运算符，他是 JavaScript 的唯一一个右结合的运算符，就是 ** Exponental， 这个也是一个后加的它表示乘方，那么我们说我们写
3**2**3， 这个是后边的先运算，也就是说先算出来 2的3次方，再算出来 3的8次方，这里要注意，我们大部分的运算符都是左结合的，唯有 ** 它是右结合的，
这个就让 JavaScript 的表达式变得非常的复杂，如果我们要做语法解析，这个结构也是非常的难处理的这样的一个结构。


Multiplicative
    */%
Additive
    + -
Shift
    <<  >>  >>>
Relationship
    <  >  <=  >=   instanceof   in
这里介绍的，优先级更低，也是更高一级的语法结构，就是乘除运算这个就是大家所最熟悉的，注意：除了传统的乘除，JS 里还支持了一个取余运算 %,以及加减运算，
加减运算就真的只是加减运算，那么乘除一定会对所有的数字都要求它必须得是 Number 类型，所以它也会发生类型转
换；
加呢，其实在JavaScript 里面有两种加法，第一种是把两个字符串连接起来，第二种是把两个数字相加，那么这个其
实设计成同一个加号是比较容易混淆的，所以这个地方加号的类型转换是比较复杂的，
另外就是位运算，移位运算，移位运算也是位运算的一种，左移右移，这个带符号的右移；
以及关系比较表达式，这个有  <  >  <=  >=  instanceof 和 in ，前面四种都是会对两边是不是数字有一定的
要求。
当然了，JS 中还设计了一个字符串的比较方法，具体就是比较两个字符串的字典顺序，作者不太建议大家利用这个字符
串的比较算法，非常容易出错。


Equality
    ==
    !=
    ===
    !==
Bitwise
    & ^ |
 优先级再低一点的就是相等的比较，那么有我们JavaScript 里面臭名昭著的双等号，这个双等号在 JS 里面，是
 类型转换最为复杂的一种运算，他基本的原则就是类型相等的时候，当然正常的比较，类型不同的时候，那么他会优先
 的把布尔型的变量，给它转换成Number 类型，这是非常的违反人类的直觉 ，所以这个问题很多，作者本人也不敢保
 证说总是能够记对双等号的转换规则，所以我们有很多的编程规范，建议就是不用，但是我有个建议，就是说大家如果
 说可以确定两边的类型，是相同的类型，或者说一边是字符串，一边是 Number，那么我觉得还是可以用双等号的，
 但是你要对两边的类型比较有信心才可以；
 然后就是经典的位运算，按位与、异或 和 按位或，它们的优先级比相等的比较还是要更低一些。


 Logical
    &&
    ||
 逻辑运算基本上是优先级最低的，与和或的关系，注意这个逻辑运算它有一个叫做短路原则，
 那么就是说如果 && 的前半部分得到的结果是 false 的话，那么后边的部分的表达式根本就不会被执行；
 || 如果说前面的是 true ,那么后边就不会被执行；
 所以说 && 和 || 有时候会被用来代替 if.


 Conditional
    ？  ：
 最后一个运算符， Conditional 运算符它是唯一一个三目运算符，它由一个问号和一个冒号分割成三个部分，
 第一个部分是条件，第二个部分是这个条件为真的时候执行的表达式的值，第三个部分是冒号后面是条件为假的
 时候执行的值； 这个 Conditional 它也是有短路逻辑的，这一点跟他的祖先 C语言 是不一致的，也就是说
 Conditional ，当前面执行为 true 的时候，它的冒号的后半部分是不会被执行的，所以 Conditional 某
 种意义上也是可以代替 if 和 else 。

 Logical 和 Conditional 它都是有短路逻辑的，所以不能保证写在这个结构里面的所有的表达式子结构都被
 执行，其它的表达式结构都没有这个问题。


-->










<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
