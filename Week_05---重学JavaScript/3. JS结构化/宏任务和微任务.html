<!--
在前面的几次课程中，我们已经从 JS 的最小最细粒度的单元 Item ，然后讲到更大一点的
Expression ，再讲到更大一点的 Statement 这个语句，然后这节课我们来讲一些更大
一些的，这种结构化的部分，因为上面的层级他们大多数是一个互相包含的关系，所以我们就
不再按照一个一个的层级来讲，而统一把它作为结构化程序设计的这个部分来讲解，接下来我们
进入到我们今天的教学内容。
-->

<!--
JS 执行粒度 （运行时）
    宏任务
    微任务（Promise）
    函数调用（ Execution Context ）
    语句/声明 （ Completion Record)
    表达式 （ Reference )
    直接量/变量/this ......

首先思考一下，JavaScript 的执行的粒度在运行时的表示，最大的这个我们把它称作宏任务，
宏任务和微任务的区分，我们是采用了 jsc 里面的一个说法，实际上在不同的 JS 引擎里对
他们命名，可能有一些区别， 宏任务就是传给 JavaScript 引擎的任务，微任务就是在
JavaScript 引擎内部的任务， 宏任务是我们去 JavaScript 语言讨论的最大粒度的
这样的一个范围，而微任务是一个由 Promise 来产生的，在 JS 的里边，只有 Promise
会产生微任务，然后微任务里面它可能会分成几个不同的函数调用，然后再下一层就是这个语
句和声明，再下一层就是讲过的表达式和再下层的直接量。

这节课我们就去重点去讲宏任务，微任务和函数调用 这几个部分，
-->

<!--
宏任务和微任务

var x = 1;
var p = new Promise(resolve=> resolve());
p.then( ()=>x=3 );
x = 2;

                    ==>     JavaScript
                              Engine

                           x = 1;
                           p = ...
                           x = 2;
                                         MicroTask
                           x=3


                   ==>     3




对于JavaScript 引擎来说，它其实是一个静态的库的这样的一个形式，那么我们在使用JS 引擎的
时候，我们会把一段代码传给它，但是大家注意可以看一下，我写的这段代码，它并不是一个完全顺序
执行的代码，这个代码里它有一个 Promise 和 then 的这样的一个逻辑，因为这个then 已经被
resolve 掉了，所以说它会立即执行，那么所以说在我们的 JavaScript 标准里定义 then 后面
的代码应该是异步执行的，所以说最后我们可以看到这个结论是什么呢？我们塞给了 JS 引擎一段代码，
但是它产生了两个异步任务，这两个异步任务，第一个里面就是 x = 1; p = new Promise
p.then() 和 x = 2 的这一段代码，      然后第二段就是 x = 3 的这段代码，这两个异步任务，
我们就把它称作一个 MicroTask ,在 JavaScript 标准里我们把它叫做一个 job , 然后我们最后
会得到运行的结果就是3，因为有两个微任务，所以说其实最后输出的结果是其中的一个微任务的结论，把
这个代码塞给引擎并且进行执行的整个的过程，我们就会把它称作一个 MicroTask.
这就是宏任务和微任务的区分。

接下来，我们来给大家实际看一下，在 oc 里边调用 JavaScript call 引擎，它的代码是什么样子，
希望大家能由此产生一些感性的认知，我们来到 OC 的代码，因为 OC 的代码大家可能不太熟悉，看起来
有一定的困难，所以我对每一句代码都给大家加了一个 JS的伪代码作为注释，这样大家可以基本上读懂
OC 的代码了，
第一步我们首先要引一个 JavaScript 块进来，OC 里面是一个默认可以去引的这样的一个状态，
OC 是由 main 开始执行的，这些都不重要。

我们看看实际执行的这段代码，首先我们初始化一下 JS Context ,JS Context 就是 JSC 里面给
大家用的一个总的这样的一个入口，它代表着一个 JavaScript 引擎的实例，基本上可以这样理解，
那么一个 JS Context 进行创建了以后，那么它就会有一个 global 的这样的一个上下文出现，
然后我们声明一个变量，然后叫做 result ,用它来保存我们代码的执行结果，然后我们这个时候塞
给调用 Context 的 evaluate script 的方法，然后塞给它一段字符串让它去执行，塞进去的时候
就是刚才咱们看到的字符串 x = 1 ... 那一段，在我塞给引擎一段代码之后，异步的 x=3,这段
代码是否执行了呢，我们把它跑起来，看一下结果。
可以看到，最终我们在 OC 里面打印 x 的值，得到了 3，也就是说这个 x = 3 的这段代码是最后
执行的，这说明我们的确在 evaluate script 这一个函数里面执行了两个异步任务，所以最后我
们得到了 x = 3 这个结论，这就是 JavaScript 引擎的一个异步机制，这是宏任务和为微任务。
-->

<!--
事件循环
       wait          =>          get code

          =>       execute          <=

其实事件循环这也是一个跳出了 JavaScript 的这样的一个概念，它是我们如何去使用 JavaScript
引擎的这样的过程，事件循环这个词 event loop 本身是来自于 node 里面的一个概念，而浏览器
里有类似的东西，但是一般来说一般的资料里我们不会叫这个名字，事件循环其实我们掰开了说其实它
只有是三个部分，第一个部分就是获取代码获取了一段代码，然后第二步就是把代码执行掉，然后等待
然后继续获取代码，这个等待的过程中有可能是在等待一个时间，有可能在等待一个事件，那么一般来
说我们在 OC 里会把它实现成，等待一个锁，然后有不同的条件去触发锁，然后来继续进行执行，所
以事件循环它将会是一个独立的线程，里面去执行这个事情，这块我们不去展开。

准备了一段 OC 代码，帮助大家理解事件循环。
给大家做了一个 JS 的 console

while(true){
     char source[1024];
     printf("js:>");
     fgets(source, 1024, stdin);

     result = [context evaluateScript;[NSString stringWithUTF8String:source]];
     NSLog(@"%",result);
}

前面的三句是 OC 的代码，那么分别是申请了一块内存，然后打印了一个提示符，然后以及获取一行作为一个
字符串，那么这个 OC 具体的逻辑大家不需要太关心，大家只要知道它在干什么就可以了。
然后我把获取来的source 字符串，给它传给 JS Context 去执行，去 evaluate script ，跟我们上面
的使用的是一摸一样的，然后我们再把它的 result 打印出来。

实际上我们真实的事件循环里，这个地方应该是一个等待锁的这样的过程，而不是像我们这样直接去获取了，
从控制台获取了一段字符串，但是不论如何，这段代码其实就向大家讲了一个事件循环，大概是长成什么样子的，
其实它无非就是等待加上获取代码，然后执行代码，其实就是这么简单的一个过程，我们的浏览器环境可能要
等待一些用户的，输入事件，我们的 node 环境里面，JavaScript 引擎可能就要等待一些什么 IO 操作
的结束，什么网卡那边过来的新的请求，等待一些这样的事件，那么所以说这个东西它在 node 里面，它就
称作事件循环，其实如果你要是写一个用到了 JSC 或者是其他引擎的应用，也免不了会这样去实现，这是一个
非常通用的一个思路，但其实它不属于 JS 引擎 或者说 JS 语言本身的内容。



-->







<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
