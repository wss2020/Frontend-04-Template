<!--
选择器的优先级

简单选择器计数
     1         2
    #id  div.a#id{
       //...
    }

    [0,2,1,1]
    S = 0* N3 + 2*N2 + 1*N1 + 1
    取 N = 1000000

    S = 2000001000001

    选择器优先级，它其实是对一个选择器里面包含的所有简单选择器进行计数，所以为什么我们说选择器列表，
我们不把它视为一个完整的选择器，因为选择器列表，它中间是以逗号分隔开的，这些复杂选择器，来进行简单
选择器计数的，
    比如说在我们题中的例子里，#id空格div.a#id, 这个里面包括了两个 id 选择器， 一个div选择器，
和一个 class 选择器，这个时候我们选择器，根据选择器的优先级，我们会把选择器的优先级，算出来是
0211 ，在选择器的标准里，有这样的一个描述，就是说我们会采用一个 N 进制来表示，所以0211 你
可以视为，它是一个巨大无比的进制里面的4 位，所以如果我们取这个 N 作为进位，那么 S 整个的优
先级也就是 specificity , S 就等于 0 乘以 N 的 3 次方 加上 2 乘以 N 的二次方，加上 1
乘以 N 的一次方 再加1 ，我们只要取一个足够大的 N 算出来，就是选择器的优先级了，
    比如说我们取一个 100 万，我们采用十进位制，比较容易符合大家的职级，那最后算出来的优先级，
就说 2000001000001 ，像 IE 的老版本，因为 N 取的值不够大，它要节省内存取了个 255，所以就
发生了一些，非常好玩的事情，比如说导致我们 256 个class 就相当于一个 id ，这个以前都有人做过
实验，老版本的 IE6 上确实是这样，后来我们大部分的浏览器，都选择了 65536，选择 65536 之后，
基本上就再也没有发生过，超过额度的事了，现在浏览器一般都会采取更保守，选取一个足够大的值，虽然
标准上描述就是N 你取的值，只要足够大就可以，
    一般我们的标准里面，它都会采用，因为你要去节约内存的占用嘛，选一个十进制比较整的数，它会选
取一个16 进制上比较整的数，一般来说都是 256 的整次幂，因为256 正好是一个字节，所以说要么一位
占一个字节，要么占两个字节， 占一个字节，就是256 进制了，这就发生了 IE 的惨剧，但其实你想一想，
虽然它是一个 BUG , 但是如果我们有谁的选择器里面真写了 256 个简单选择器的话，那我觉得这个人脑子
是有点问题的，所以选择器，大家还是不要写的太复杂，但是 specificity 的计算原理，大家是一定要记
住。
-->

<!--
小练习：
请写出下面选择器的优先级
    div#a.b .c[id=x]
    #id:not(#b)
    *.a
    div.a
-->


