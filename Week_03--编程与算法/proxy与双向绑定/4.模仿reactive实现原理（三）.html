<!--
 接下来我们要给 reactive 和 effect 之间，建立一个这样的连接， 在JavaScript 里边，
 其实没有任何办法，我们能够获取一个函数，它能够访问到的所有的变量，实际上即使我们能获得，
 它访问到哪些变量，我们也没有任何的数据结构，能够去表示它，那么这里，我们又用了一个非常
 独特的这样的一个技术；
 我们虽然没有办法，去获取一个函数里面引了哪些变量，但是我们有办法去调用一下这个函数，然后
 我们看看它实际用了哪些变量，那么实际用了哪些变量呢？ 如果它引了一个普通的变量，我们也没有
 办法去监听它，但如果它引了一个 reactive ，我们就有办法在这个 reactive 的 get 里面，
 那么去获得这样的一个监听的效果，所以说接下来就让我们来尝试，去在 effect 这个函数里面做
 一些文章，看一看能不能够把这个函数调用了 object 的哪些属性，给它获取出来。


-->

<script>
    let callbacks = []

    // 首先我们准备一个全局的变量,我们去尝试去调用一次 effect 的函数，然后我们在 reactive 的 get 里面，把它注册进 usedReactivties 里面，
    // 这样的话，执行完之后，我们就知道它用到了哪些变量了，
    let usedReactivties = [];


    let object = {
        a: 1,
        b: 2
    }

    let po = reactive(object);

    effect(() => {
        console.log(po.a);
    })


    function effect(callback) {
       // callbacks.push(callback);
        // 首先这里，先把 usedReactivties 清空,然后我们去调用一下 callback,调用 callback 的过程中，它就会不可避免的，它如果真的引到了
        // reactive 的对象，po 这类的对象是不是，那么它就会在 get 里面，发生一个注册的行为，我们就在这里，把 usedReactivties 给它push
        // 一对参数进去;   这样在 effect 结束之后，我们就知道它调用了那些的变量了，我们在这里先不处理，先console.log() 看一下，
        // 打印输出，能看到，我们正确地收集到了依赖关系，这是一个对象这是一个值， 那么这个时候，我们要把usedReactivties 里面，给它存起来，
        // 那么我们还是可以利用 callbacks ，
        usedReactivties = [];
        callback();
        console.log(usedReactivties);
    }

    function reactive(object) {
        return new Proxy(object, {
            set(obj, prop, val) {
                obj[prop] = val;
                for(let callback of callbacks){
                    callback();
                }
                return obj[prop];
            },
            get(obj, prop) {
                usedReactivties.push(obj,prop);
                return obj[prop];
            }
        })
    }

</script>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
